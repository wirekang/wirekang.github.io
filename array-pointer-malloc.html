<!DOCTYPE html>
<html lang="KR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="공사중인 블로그입니다.">
    <style>

@font-face {
 font-family: 'NanumBarunGothic';
 font-style: normal;
 font-weight: 400;
 src: url('//cdn.jsdelivr.net/font-nanumlight/1.0/NanumBarunGothicWeb.eot');
 src: url('//cdn.jsdelivr.net/font-nanumlight/1.0/NanumBarunGothicWeb.eot?#iefix') format('embedded-opentype'), url('//cdn.jsdelivr.net/font-nanumlight/1.0/NanumBarunGothicWeb.woff') format('woff'), url('//cdn.jsdelivr.net/font-nanumlight/1.0/NanumBarunGothicWeb.ttf') format('truetype');
}

@font-face {
 font-family: 'NanumBarunGothic';
 font-style: normal;
 font-weight: 700;
 src: url('//cdn.jsdelivr.net/font-nanumlight/1.0/NanumBarunGothicWebBold.eot');
 src: url('//cdn.jsdelivr.net/font-nanumlight/1.0/NanumBarunGothicWebBold.eot?#iefix') format('embedded-opentype'), url('//cdn.jsdelivr.net/font-nanumlight/1.0/NanumBarunGothicWebBold.woff') format('woff'), url('//cdn.jsdelivr.net/font-nanumlight/1.0/NanumBarunGothicWebBold.ttf') format('truetype')
}

@font-face {
 font-family: 'NanumBarunGothic';
 font-style: normal;
 font-weight: 300;
 src: url('//cdn.jsdelivr.net/font-nanumlight/1.0/NanumBarunGothicWebLight.eot');
 src: url('//cdn.jsdelivr.net/font-nanumlight/1.0/NanumBarunGothicWebLight.eot?#iefix') format('embedded-opentype'), url('//cdn.jsdelivr.net/font-nanumlight/1.0/NanumBarunGothicWebLight.woff') format('woff'), url('//cdn.jsdelivr.net/font-nanumlight/1.0/NanumBarunGothicWebLight.ttf') format('truetype');
}

@font-face {
    font-family: 'D2Coding';
    src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/noonfonts_three@1.0/D2Coding.woff') format('woff');
    font-weight: normal;
    font-style: normal;
}

html{
    font-size: 16px;
    font-family: 'NanumBarunGothic', sans-serif;
    width:100%;
    height:100%;
    margin: 0;
    padding: 0;
    display:flex;
    justify-content: center;
}

body{
    width:100%;
    height:97%;
    max-width: 900px;
    padding:0.5rem;
    margin: auto 0;
    background-color: #f7f7f5;
}

#container{
    width:100%;
    height:100%;
    display:flex;
    flex-direction: column;
    justify-content: flex-start;
}

div.btitle{
    
    font-size: 1.5rem;
    
    text-align:center;
    padding-top: 0.3rem 0;
}

div.description{
    font-size: 1rem;
    text-align:center;
    padding-top: 1rem;
    padding-bottom: 1rem;
}

div.tags{
    font-size: 1rem;
    display:flex;
    flex-direction: row;
    flex-wrap: wrap;
}

div.tags a{
    border: 1px solid #aaa;
    padding: 0.2rem;
}

p.filter{
    font-size: 1.2rem;
    text-align: center;
}

a.post{
    border-top: 1px solid #ccc;
    display:block;
    padding: 0.1rem;
    font-size: 1.1rem;
}

a.post span.title{
    float:left;   
}

a.post span.date{
    float:right;
}

div.single{
    background-color: white;
    padding: 1rem;
}

div.single div.title{
    font-size: 2rem;
    font-weight: bold;
    text-align:center;
    padding-top: 1rem;
}

div.single div.tag{
    text-align: right;
}
a.toc{
    font-size:1.2rem;
    line-height: 1.4rem;
}

a.toc-h1{
    margin-left: 0rem;
}

a.toc-h2{
    margin-left: 2rem;
}

a.toc-h1::before{
    font-size: 0.6rem;
    content: "■ "
}

a.toc-h2::before{
    font-size: 0.6rem;
    content: "● "
}

code {
    font-family: 'D2Coding';
}

a.nodeco{
    text-decoration: none;
    color:rgb(0, 0, 0);
}

a.nodeco:hover{
    color:#11a;
}

a.gray{
    color: #777;
}

.footer{
    margin-top: auto;
    padding-top:1rem;
    padding-bottom: 0.3rem;
    justify-self: flex-end;
    display:flex;
    flex-direction: row;
    justify-content: center;
    font-size: 0.6rem;

}

</style>
    <title>wirekang 블로그</title>
</head>
<body>
<div id="container">
    <div class="btitle">
        <a class="nodeco" href="/">wirekang 블로그</a>
    </div>

    

    
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.4.1/styles/a11y-dark.min.css" integrity="sha512-1rzCaYWsg3l6uKvGbUT6rAZFOcVn0zeXAFlZudsnj8k2xcrU5asL8jfJUEijV9GPYMh0GnPToeCTJj6RXQnA8g==" crossorigin="anonymous" />
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.4.1/highlight.min.js"></script>
<script>
    function doTOC(){
        const post = document.getElementById("post")
        const toc=document.getElementById("toc")
        const headings = Array.from(post.getElementsByTagName("*")).filter( 
            e=> (e.tagName=="H1" || e.tagName=="H2")
        )
        
        let tocInner="<h1 class='toc'>목차</h1>"
        let index = 0
        headings.forEach(h => {
            h.id=index++
            tocInner+=`<a class="nodeco toc toc-${h.tagName.toLowerCase()}" href="#${h.id}">${h.innerHTML}</a></br>`
            h.innerHTML=`<a class="nodeco" href="#toc">${h.innerHTML}</a>`
            
        })
        console.log(headings)
        console.log(tocInner)
        toc.innerHTML = tocInner
    }
    
    hljs.initHighlightingOnLoad();
    document.addEventListener("DOMContentLoaded",doTOC)
</script>
<div class="single">
    <div class="title">
        <a class="nodeco" href="array-pointer-malloc.html">배열 포인터 동적할당 메모리</a>
    </div>
    <div class="tag">
        
            <a class="nodeco gray" href ="tag1.html">#프로그래밍</a>
        
            <a class="nodeco gray" href ="tag2.html">#굉장히</a>
        
            <a class="nodeco gray" href ="tag3.html">#아주</a>
        
            <a class="nodeco gray" href ="tag4.html">#크게</a>
        
            <a class="nodeco gray" href ="tag5.html">#다양한</a>
        
            <a class="nodeco gray" href ="tag6.html">#많은</a>
        
            <a class="nodeco gray" href ="tag7.html">#태그</a>
        
    </div>
    <div id="post">
        <div id="toc"></div>
        <hr>
        <h1>들어가기 앞서</h1>

<p>이 글은 배열, 포인터, 동적 할당 등 메모리를 다룰 때 필요한, 근본적인 이해를 돕기 위해 작성되었습니다. 포인터가 무엇인지 전혀 모르는 독자에게 이 글은 불친절하게 느껴질 수 있습니다. 이 글의 목적은 애매하게 알고 있는 지식들을 근본적으로 이해할 수 있게 하는 것 입니다.
 앞으로 메모리의 구조를 쉽게 파악할 수 있는 표를 사용할 것 입니다.</p>

<p><code>int i;</code></p>

<p>위의 코드를 실행하고 난 직후의 메모리를 표로 나타내면 다음과 같습니다. (이 글에서는 int형의 크기를 4byte로 정하겠습니다.)</p>

<p>table
1015: i
1015~1018: ?</p>

<p><strong>해석</strong>
 자료형이 int인 변수 i가 선언되었기 때문에, 메모리의 무작위 위치에 i를 위한 공간이 할당되었습니다. int는 4byte의 크기를 가지는 자료형이기 때문에 그 공간의 크기도 4byte입니다. 선언은 했지만 초기화를 통해 값을 넣는 행위를 아직 하지 않았습니다. 그렇기 때문에 i가 할당된 공간에는 어떤 값이 들어있을지 알 수 없으며 이를 쓰레기값 이라고 합니다. 앞으로 쓰레기 값을 ?로 표기할 것입니다.
 이 사실을 표에서 확인 할 수 있습니다. 1015번 주소를 기준으로 딱 한칸, 즉 한개의 바이트만 할당되어 있고 쓰레기 값이 들어 있습니다. 파란색 i라는 글자를 통해 i변수가 1015번 부터 할당 되었다는 사실을 알 수 있습니다.</p>

<p><em>주의: 가독성과 편한 이해를 위해 1015같은 짧은 4자리 수를 주소값으로 사용했지만 실제로는 0xffffffffda0같은 16진수 값이 메모리 주소를 나타내는데 사용됩니다.</em></p>

<p>이어서 다음 코드를 실행하겠습니다.</p>

<pre><code class="language-c"> i = 10;
 int *p;
</code></pre>

<p><code>printf(&quot;%d&quot;, i); // 10</code></p>

<p>table
1015: i
1015~1018: 10</p>

<p>1020: p
1020~1023: ?</p>

<p>i에는 10이라는 값이 들어갔습니다. 표에서는 가독성을 위해 그냥 &lsquo;10&rsquo;이라는 글자가 쓰여있지만, 실제로는 00101010100&hellip; 같은 32자리 2진수 값이 1015번 바이트부터 1018번 바이트에 걸쳐 저장되어 있습니다. 이 이진수를 int형의 규칙으로 해석했을 때 10이라는 값이 나오는 것 입니다. 32자리인 이유는 한개의 바이트가 8자리의 이진수를 저장할 수 있기 때문입니다.(8 x 4 = 32)
 이후 p라는 새로운 변수가 선언되었습니다. 역시 메모리의 무작위 위치에 할당되었습니다. p는 int형 포인터 변수입니다. 포인터의 크기는 운영체제가 32bit 환경인지 64bit 환경인지에 따라 달라지지만, 이 글에서는 포인터의 크기를 4byte (32bit)로 정하겠습니다. 그래서 p는 1020부터 1023, 4개의 바이트에 할당되었습니다. 역시 따로 값을 넣어주지 않았기 때문에 쓰레기값이 들어 있습니다.</p>

<h2>모든 포인터의 크기가 동일한 이유</h2>

<p>포인터에 대한 이해가 충분하지 않을 경우, &ldquo;int는 4byte의 크기를 가지고, double은 8byte인데 어떻게 int 포인터와 double 포인터가 같은 크기를 가지는가?&rdquo; 같은 의문이 들 수 있습니다.
 포인터는 int, char, double 등과 마찬가지로 자료형의 일종입니다. 모든 자료형은 정해진 크기가 존재하고, 그 정해진 크기의 공간을 각자만의 방식으로 사용합니다. 예를 들어 char은 1byte의 공간을 문자 하나를 표현하는데 사용합니다. int와 float는 둘 다 4byte의 크기를 가지지만, int는 정수를 표현하는 반면에 float는 같은 크기의 공간을 실수를 표현하는데 사용합니다. 포인터라는 자료형은 언급했던 것 처럼 4 또는 8byte의 공간을 메모리 주소를 표현하는데 사용합니다. char형 포인터냐, int형 포인터냐 같은 여부는 전혀 상관이 없습니다.
 그럼 &ldquo;ㅁㅁ형 포인터&rdquo; 라는 것이 무엇을 뜻하는지 궁금하실 겁니다. 이를 설명하기 위해 코드를 한 단계 더 진행하겠습니다.</p>

<pre><code class="language-c">p = &amp;i;
</code></pre>

<p>table
1015: i
1015~1018: 10</p>

<p>1020: p
1020~1023: 1015</p>

<p>p변수의 값에 &amp;i를 넣었습니다. &amp;i는 i변수가 할당되어 있는 메모리 주소를 나타냄으로, p에는 1015가 저장됩니다. 여기까지의 과정에서 p가 int형 포인터라는 점이 크게 개입하지 않았습니다.
 이어서 다음 코드를 진행하겠습니다.</p>

<pre><code class="language-c">*p = 20;
</code></pre>

<p><code>printf(&quot;%d %d&quot;, i, *p); // 20 20</code></p>

<p>table
1015: i
1015~1018: 20</p>

<p>1020: p
1020~1023: 1015</p>

<p><pre>*p</pre>는 p변수가 저장하고 있는 값, 즉 메모리 주소에 접근하겠다는 뜻입니다. p변수의 값은 1015입니다. 그래서 위의 코드는 1015번 주소의 값을 20으로 변경하라는 뜻이고, 이는 <em>i = 20;</em> 과 같은 역할입니다. 그래서 i의 값이 20으로 바뀌어 있는 것을 볼 수 있습니다.
 드디어 &ldquo;int형 포인터&rdquo; p가 제 역할을 하는 순간입니다. p는 포인터이고, p의 값은 메모리의 주소입니다. C언어 입장에서는 메모리의 주소만으로는 그 위치에서 어디까지 할당되어 있는지, 어떤 형태로 해석해야 하는지 알 수 없습니다. 이것을 알려주는 것이 &ldquo;ㅁㅁ형 포인터&rdquo;의 역할입니다.
 p가 int형 포인터 라는 것은 <strong>&ldquo;p가 저장하고 있는 메모리 주소부터 int형의 크기만큼의 바이트를 int로 해석하라&rdquo;</strong> 라는 뜻입니다. 이 정보가 있었기 때문에 1015번 주소부터 1018번 주소의 바이트에 20을 뜻하는 값이 들어갈 수 있었습니다.</p>

<h1>배열</h1>

<p>앞서 기본적인 변수와 포인터가 어떤 식으로 할당되는지 알아봤습니다. 이번에는 배열에 대해서 알아보겠습니다.</p>

<pre><code class="language-c">int arr[3] = {10,20,30};
</code></pre>

<p>table
1002: arr
1002~1005: 10
1006~1009: 20
1010~1013: 30</p>

<p>크기 3짜리 int배열이 선언과 동시에 초기화 되었습니다. int 4byte의 크기를 가진 자료형임으로, 1002번부터 10013번까지 각 원소당 4byte, 총 12byte가 arr을 위해 할당되었습니다. 일반적으로 배열의 각 원소에 접근하는 방법은 다음과 같습니다.</p>

<p><code>printf(&quot;%d %d %d&quot;, arr[0], arr[1], arr[2]); // 10 20 30</code></p>

<p>잠시 맨 처음에 등장했던 예시를 보겠습니다.</p>

<p>table
1015: i
1015~1018: 20</p>

<p>1020: p
1020~1023: 1015</p>

<p>변수에 저장된 값이란, 그 변수가 할당된 메모리 공간에서 그변수의 자료형 크기만큼의 바이트를 그 자료형의 방식으로 해석 한 것을 말합니다. 거듭 강조하지만, i의 값이 20인 이유는 i가 할당된 1015번 주소부터 4개의 바이트를 int로 해석했을 때 20이 나오기 때문입니다. p 역시, 1020번부터 4개의 바이트를 메모리 주소로 해석했을 때 나오는 값인 1015가 p의 값입니다.
 이해가 끝났다면 다시 배열로 돌아와서 다음 코드를 보겠습니다.</p>

<p><code>printf(&quot;%d&quot;, arr); // 1002</code></p>

<p>arr은 아까 선언했든 크기 3짜리 int 배열이지만, 일단 arr이 뭔지 잊어버리고 위 코드를 해석하면 다음과 같습니다.
<strong>arr 변수의 값은 1002이다.</strong>
 표를 다시 한번 보겠습니다.</p>

<p>table
1002: arr
1002~1005: 10
1006~1009: 20
1010~1013: 30</p>

<p>표에 문제가 있는 것이 아니라면, 1002이란 값은 어디에도 저장되어 있지 않습니다. 분명 arr의 값을 출력했을 때는 1002이 나왔는데, 실제로는 arr이 할당된 1002번 주소부터 몇개의 바이트를 어떻게 해석해도 1002이란 값은 나올 수 없습니다. 일단 arr이 1002번에 할당되어 있지 않을 수도 있기 때문에 다음 코드를 보겠습니다.</p>

<p><code>printf(&quot;%d&quot;, &amp;arr); // 1002</code></p>

<p>직접 출력을 해 봐도 arr이 할당된 곳은 1002번이라는 결과가 나옵니다. 그럼 arr 배열의 요소들은 어디에 할당되어 있는지 확인해보겠습니다.</p>

<p><code>printf(&quot;%d %d&quot;, &amp;( arr[0] ), &amp;( arr[1] )); // 1002 1006</code></p>

<p>표와 마찬가지로 1002번 부터 4byte씩 할당되어 있습니다. 굉장한 모순입니다. 지금까지의 정황에 따르면 1002번 주소부터 arr배열의 원소들이 순서대로 저장되어 있는데, 동시에 1002라는 값도 저장되어 있습니다.
 이런 모순이 가능한 이유가 있습니다. C에서 배열은 특별한 존재입니다. 일반적인 변수와는 다른 개념으로, 컴파일러가 직접 다른 공간에서 관리하는 예외적인 존재입니다. arr은 배열이 할당 된 공간의 시작 주소를 나타내며, &amp;arr역시 마찬가지지만 차이가 존재합니다. 일단 지금은 &amp;arr에 대해서 다루지 않겠습니다.
 어찌되었든 arr이 주소를 나타내기 때문에, 포인터 처럼 사용할 수 있습니다.</p>

<pre><code class="language-c">*arr = 40; 
</code></pre>

<p>table
1002: arr
1002~1005: 40
1006~1009: 20
1010~1013: 30</p>

<p>arr변수가 가지고 있는 메모리 주소에 접근해서 값을 40으로 주었습니다. 포인터 연산이 그대로 가능하기 때문에 뭐하러 먼 길을 돌아서 설명했나 싶을 수도 있습니다. 그러나 추후에 더욱 복잡한 구조를 근본적으로 이해하려면, 이런 예외를 잘 숙지하고 있어야 합니다.</p>

<h1>포인터 연산</h1>

<h1>동적 할당</h1>

<h1>2차원 배열</h1>

<h1>유사 2차원 배열 동적할당</h1>

<h1>2차원 배열 동적할당</h1>

    </div>
</div>
<div class="related">
    <p class="filter">관련된 글</p>
    
        
    <a class="nodeco post" href="code-test.html">
        <span class="title">코드 하이라이팅 테스트용 글</span>
        <span class="date">2020-12-7</span>
    </a>
    </br>

    
        
    <a class="nodeco post" href="heading-test.html">
        <span class="title">목차 테스트용 글입니다.</span>
        <span class="date">2020-12-7</span>
    </a>
    </br>

    
        
    <a class="nodeco post" href="test2.html">
        <span class="title">두 번째 테스트용 글입니다.</span>
        <span class="date">2020-12-6</span>
    </a>
    </br>

    
</div>

    <div class="footer">
        <a href="https://github.com/wirekang/blogen">Powered by blogen</a>
    </div>
</div>
</body>
</html>

