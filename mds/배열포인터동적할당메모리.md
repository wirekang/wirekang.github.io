# 들어가기 앞서
 이 글은 배열, 포인터, 동적 할당 등 메모리를 다룰 때 필요한, 근본적인 이해를 돕기 위해 작성되었습니다. 포인터가 무엇인지 전혀 모르는 독자에게 이 글은 불친절하게 느껴질 수 있습니다. 이 글의 목적은 애매하게 알고 있는 지식들을 근본적으로 이해할 수 있게 하는 것 입니다.
 앞으로 메모리의 구조를 쉽게 파악할 수 있는 표를 사용할 것 입니다.
 
```int i;```
 
 위의 코드를 실행하고 난 직후의 메모리를 표로 나타내면 다음과 같습니다. (이 글에서는 int형의 크기를 4byte로 정하겠습니다.)
  
표표표 1015-1018|?|i

**해석**
 자료형이 int인 변수 i가 선언되었기 때문에, 메모리의 무작위 위치에 i를 위한 공간이 할당되었습니다. int는 4byte의 크기를 가지는 자료형이기 때문에 그 공간의 크기도 4byte입니다. 선언은 했지만 초기화를 통해 값을 넣는 행위를 아직 하지 않았습니다. 그렇기 때문에 i가 할당된 공간에는 어떤 값이 들어있을지 알 수 없으며 이를 쓰레기값 이라고 합니다. 앞으로 쓰레기 값을 ?로 표기할 것입니다.
 이 사실을 표에서 확인 할 수 있습니다. 1015번 주소를 기준으로 딱 한칸, 즉 한개의 바이트만 할당되어 있고 쓰레기 값이 들어 있습니다. 파란색 i라는 글자를 통해 i변수가 1015번 부터 할당 되었다는 사실을 알 수 있습니다.

*주의: 가독성과 편한 이해를 위해 1015같은 짧은 4자리 수를 주소값으로 사용했지만 실제로는 0xffffffffda0같은 16진수 값이 메모리 주소를 나타내는데 사용됩니다.*

 이어서 다음 코드를 실행하겠습니다.

 ```c
 i = 10;
 int *p;
 ```
 ```printf("%d", i); // 10```

표표표 1015-1018,32,i    1020-1023,?,p 

 i에는 10이라는 값이 들어갔습니다. 표에서는 가독성을 위해 그냥 '10'이라는 글자가 쓰여있지만, 실제로는 00101010100... 같은 32자리 2진수 값이 1015번 바이트부터 1018번 바이트에 걸쳐 저장되어 있습니다. 이 이진수를 int형의 규칙으로 해석했을 때 10이라는 값이 나오는 것 입니다. 32자리인 이유는 한개의 바이트가 8자리의 이진수를 저장할 수 있기 때문입니다.(8 x 4 = 32)
 이후 p라는 새로운 변수가 선언되었습니다. 역시 메모리의 무작위 위치에 할당되었습니다. p는 int형 포인터 변수입니다. 포인터의 크기는 운영체제가 32bit 환경인지 64bit 환경인지에 따라 달라지지만, 이 글에서는 포인터의 크기를 4byte (32bit)로 정하겠습니다. 그래서 p는 1020부터 1023, 4개의 바이트에 할당되었습니다. 역시 따로 값을 넣어주지 않았기 때문에 쓰레기값이 들어 있습니다.

## 모든 포인터의 크기가 동일한 이유
 포인터에 대한 이해가 충분하지 않을 경우, "int는 4byte의 크기를 가지고, double은 8byte인데 어떻게 int 포인터와 double 포인터가 같은 크기를 가지는가?" 같은 의문이 들 수 있습니다.
 포인터는 int, char, double 등과 마찬가지로 자료형의 일종입니다. 모든 자료형은 정해진 크기가 존재하고, 그 정해진 크기의 공간을 각자만의 방식으로 사용합니다. 예를 들어 char은 1byte의 공간을 문자 하나를 표현하는데 사용합니다. int와 float는 둘 다 4byte의 크기를 가지지만, int는 정수를 표현하는 반면에 float는 같은 크기의 공간을 실수를 표현하는데 사용합니다. 포인터라는 자료형은 언급했던 것 처럼 4 또는 8byte의 공간을 메모리 주소를 표현하는데 사용합니다. char형 포인터냐, int형 포인터냐 같은 여부는 전혀 상관이 없습니다.
 그럼 "ㅁㅁ형 포인터" 라는 것이 무엇을 뜻하는지 궁금하실 겁니다. 이를 설명하기 위해 코드를 한 단계 더 진행하겠습니다.

```c
p = &i;
```
 
표표표 1015-1018,10,i      1020-23,1015,p 

 p변수의 값에 &i를 넣었습니다. &i는 i변수가 할당되어 있는 메모리 주소를 나타냄으로, p에는 1015가 저장됩니다. 여기까지의 과정에서 p가 int형 포인터라는 점이 크게 개입하지 않았습니다.
 이어서 다음 코드를 진행하겠습니다.

```c
*p = 20;
```
```printf("%d %d", i, *p); // 20 20```

표표표 1015-18,20,i     1020-23,1015,p

 <pre>*p</pre>는 p변수가 저장하고 있는 값, 즉 메모리 주소에 접근하겠다는 뜻입니다. p변수의 값은 1015입니다. 그래서 위의 코드는 1015번 주소의 값을 20으로 변경하라는 뜻이고, 이는 *i = 20;* 과 같은 역할입니다. 그래서 i의 값이 20으로 바뀌어 있는 것을 보실 수 있습니다.
 드디어 "int형 포인터" p가 제 역할을 하는 순간입니다. p는 포인터이고, p의 값은 메모리의 주소입니다. C언어 입장에서는 메모리의 주소만으로는 그 위치에서 어디까지 할당되어 있는지, 어떤 형태로 해석해야 하는지 알 수 없습니다. 이것을 알려주는 것이 "ㅁㅁ형 포인터"의 역할입니다.
 p가 int형 포인터 라는 것은 **"p가 저장하고 있는 메모리 주소부터 int형의 크기만큼의 바이트를 int로 해석하라"** 라는 뜻입니다. 이 정보가 있었기 때문에 1015번 주소부터 1018번 주소의 바이트에 20을 뜻하는 이진수 값이 들어갈 수 있었습니다.
